# Змията

<img src="https://dl.dropboxusercontent.com/u/10864790/snake.png" />

## Подход

В Clojure света вярваме, че безпричинното използване на mutable състояния е
причината за доста от проблемите, пред които сме изправени, пишейки
софтуер. Когато нещата не се променят, те са по-прости и да мислим за тях е
по-лесно.

В тази задача ще упражним способностите си да решаваме проблеми без да ползваме
променящи се състояния и ще видим как това води до драстично по-прост
код. Ще комбинираме функции без странични ефекти, persistent структурите и
мощните clojure.core инструменти за трансформации на данни в едно идеоматично
решение на проблема със [змията](http://en.wikipedia.org/wiki/Snake_(video_game).

Тук ще засегнем и друга важна идея в езика - програмиране ориентирано към
данните. За разлика от OOP подхода, където код и данни "живеят" заедно в
класове, тук имаме много ясно разделение между логиката на нашата програма и
информацията, с които тя работи. Заменяме моделирането на йерархии от класове и
взаимодействията между тях с моделиране на данните, с които ще работи програмата
ни и трансформациите, които ще им прилагаме, за да постигнем желаните резултати.
Друг важен момент е, че не крием данните зад абстракции, като класове, а ползваме
директно суровите структури от данни.

И така логиката на нашата програма ще представлява, един поток от immutable
трансформации, които решават проблема, който сме си поставили, трансформирайки
начални данни в желаните резултатни данни.

Често искаме да покажем тези резултати на света извън програмата ни и да го
променим по някакъв начин. Постигаме това с минимален брой, координирани
странични ефекти на точно определени за това места.

## Данни

Ще описваме змия със структурата от данни показана по-долу. За удобство надолу
ще наричаме тази структура *змията*.

```clojure
  {:dir [0 1]
   :width 10
   :height 10
   :prizes #{[3 8] [1 8]}
   :location [[3 3] [3 4] [3 5] [3 6]]}
```
* `dir` е вектор с две числа (-1, 0 или 1), който описва посоката на движение.
  Първият елемент е промяната по `x`, а втория - по `y` координатата. Например:
  `[0 1]` ще описва движени надолу, а `[0 -1]` движение нагоре. Можем да се
  движим само нагоре, надолу, наляво и надясно, но не и по диагонал.
* `location` е вектор с всички последователни точки, на които е разположена
  нашата змия, като последната точка е позицията на главата.
* `prizes` е множество с всички точки, на които има награди за ядене.
* `width` и `height` са размерите на полето.

## Трансформации

### move

Напишете функция `move`, която приема *змията* и връща състоянието ѝ след
преместване с един ход в текущата посока.

* Ако не вземаме награда с това движение, първата точка от `location` се маха, а
  точката от главата в посоката на движение, се добавя на последно място в
  `location`.
* Ако умираме - змията се прехапва или се блъскаме в стена, функцията връща `false`.
* Ако вземаме награда с това движение, нова награда се добавя на произволно
  място (но не върху змията или друга награда), първата точка от `location` не
  се маха, а само се добавя още една точка в края, което ще направи змията с една
  точка по-дълга.

Малко примери:

```clojure
  ;; Не вземаме награда
  (move {:dir [0 1]
         :width 10
         :height 10
         :prizes #{[1 3]}
         :location [[3 3] [3 4] [3 5] [3 6]]})
  ; {:location [[3 4] [3 5] [3 6] [3 7]], ...}

  ;; Вземаме награда
  (move {:dir [0 1]
         :width 10
         :height 10
         :prizes #{[3 7]}
         :location [[3 3] [3 4] [3 5] [3 6]]})
  ; {:location [[3 3] [3 4] [3 5] [3 6] [3 7]], :prizes #{[2 4]}, ...}

  ;; Умираме
  (move {:dir [0 1]
         :width 7
         :height 7
         :prizes #{[3 1]}
         :location [[3 3] [3 4] [3 5] [3 6]]})
  ; false
```
### turn

Напишете функция `turn`, която приема *змията* и ключова дума
(`:left`, `:right`, `:top` или `:bottom`) и връща нова *змия* с променена
посоката на движение.

```clojure
  (turn {:dir [0 1]
         :width 7
         :height 7
         :prizes #{[2 5]}
         :location [[3 3] [3 4] [3 5] [3 6]]}
    :left)
  ; {:dir [-1 0], ...}
```

### danger?

Напишете предиката `danger?`, която приема *змията* и проверява дали ако тя
продължава да се движи в същата посока ще умре след един или два хода.

```clojure
  (danger? {:dir [0 1]
            :width 10
            :height 10
            :prizes #{[3 7]}
            :location [[3 5] [3 6] [3 7] [3 8] [3 9]]})
  ; true
```

## Странични ефекти

Няма да ви караме да правите това в тази задача, но ако имплементирате
запазване на рекорди, UI или друго интересно допълнение, рискувате да ви
дадем бонус точки :)

## Бележки

* Разгледайте примера за minesweeper и лекцията за трансформации от данни.
* Свободни сте да си дефинирате помощни функции, имена и каквото още поискате.
* Може да използвате каквито модули си харесате в стандартната библиотека.
* [Clojure cheatsheet][cheatsheet] е ваш приятел.
* **Пуснете си примерния тест**. Целта му е да провери, че системата ни за
  проверка се справя с вашето решение. Ако има грешка при неговото изпълнение,
  ще има грешка и при проверката, в резултат на което е вероятно да имате 0
  точки.

[cheatsheet]: http://clojure.org/cheatsheet
