Напишете функция shorten-ranges, която приема низ и вектор от chars. Функцията
връща като резултат низа със съкратени в него всички поднизове, състоящи се от
повече от 2 последователни елемента на вектора. Обхождаме от ляво на дясно и
хващаме всички поднизове по-пътя, които са съставени само от последователни
елементи на вектора. Целта ни е да хванем максималните възможни поднизове,
обхождайки от ляво на дясно, които може и да не са оптималните възможни като
цяло, и да ги съкратим. Малко примери:

    (shorten-ranges "qwerty" [\q \w \e \r \t \y])        ; "q..y"
    (shorten-ranges "->01|0123|4567" (vec "0123456789")) ; "->01|0..3|4..7"

Въпреки, че в даден момент при обхождането можем да съкратим
само "aaaa", няма да го направим, тъй като съществува и по-дълга
подпоследователност от вектора, която можем да ползваме:

    (shorten-ranges "aaaabbbb" (vec "aaaa6bbbbk|aaaabbbb")) ; a..b

В случая съкращаваме "aab", защото, обхождайки от ляво на дясно, това е
оптималното, което можем да съкратим.

    (shorten-ranges "aabcc" (vec "aab%bcc")) ; a..bcc

Същото важи и за следващия пример. Въпреки че оптималното съкращение в случая е
"ba..a", от това че обхождаме от ляво на дясно и обработваме винаги първото
най-дълго срещнато съкращение, ще получим:

    (shorten-ranges "baaaaaa" (vec "baaPPaaaaaaaaaa")) ; b..aa..a

Поднизовете, съставени от 2 последователни елемента на вектора, също се обработват. В случая "aa" е подниз, съставен от последователни елементи на вектора, но "aac" не е. Когато стигнем до "c", спираме с текущия подниз и опитваме да го съкратим. След това от "c" започваме да обработваме нов подниз от последователни елементи на вектора.

    (shorten-ranges "aacaa" (vec "aa|aca")) -> "aacaa"
