# Обхвати

Напишете функция shorten-ranges, която приема низ и вектор от chars. Функцията
връща като резултат низa със съркатени в него всички поднизове, състоящи се от
повече от 2 последователни елемента на вектора. Обхождаме от ляво на дясно и
хващаме всички поднизове по-пътя, които са съставени само от последователни
елементи на вектора. Целта ни е да хванем максималните възможни поднизве,
обхождайки от ляво на дясно, които може и да не са оптималните възможни като
цяло, и да ги съкратим. Малко примери:

    (shorten-ranges "qwerty" [\q \w \e \r \t \y])        ; "q..y"
    (shorten-ranges "->01|0123|4567" (vec "0123456789")) ; "->01|0..3|4..7"

Въпреки, че в даден момент при обхождането можем да съкратим
само "aaaa", няма да го направим, тъй като съществува и по-дълга
подпоследователност от вектора, кято можем да ползваме:

    (shorten-ranges "aaaabbbb" (vec "aaaa6bbbbk|aaabbbb")) ; a..b

В случая съкращаваме aab, защото, обхождайки от ляво на дясно, това е
оптималното, което можем да съкратим.

    (shorten-ranges "aabcc" (vec "aab%bcc")) ; a..bcc

Същото важи и за следващия пример. Въпречки че оптималното съкращение в случая е
ba..a, от това че обождаме от ляво на дясно и обработваме винаги първото
най-дълго срещнато съкращение, ще получим:

(shorten-ranges "baaaaaa" (vec "baaPPaaaaaaaaaa")) ; b..aa..a
